package competition.test_2021_9_26;
//给你一个下标从 0 开始的二维数组 grid ，数组大小为 2 x n ，其中grid[r][c]表示矩阵中(r, c)位置上的点数。
//        现在有两个机器人正在矩阵上参与一场游戏。
//        两个机器人初始位置都是 (0, 0) ，目标位置是(1, n-1)。每个机器人只会向右((r, c) 到 (r, c + 1))
//        或向下 ((r, c) 到 (r + 1, c)) 。
//        游戏开始，第一个机器人从(0, 0)移动到 (1, n-1)，并收集路径上单元格的全部点数。对于路径上所有单元格
//        (r, c) ，途经后grid[r][c]会重置为0。然后，第二个机器人从(0, 0)移动到(1, n-1)，同样收集路径上单
//        元的全部点数。注意，它们的路径可能会存在相交的部分。
//        第一个 机器人想要打击竞争对手，使第二个机器人收集到的点数最小化 。与此相对，第二个机器人想要最大化自
//        己收集到的点数。两个机器人都发挥出自己的最佳水平的前提下，返回第二个机器人收集到的点数 。


/**
 * @author wy
 * @date 2021/9/26 10:37
 */
public class GridGame {
    /**
     * 第一个机器人走的是一个z字形，所过路径全部重置为0
     * 第二个机器人最多只能拿到第一行后半部分或者第二行前半部分
     * 所以第一个机器人的任务就是使得第二个机器人两种情况中的最大值最小
     * @param grid
     * @return
     */
    public long gridGame(int[][] grid) {
       int n=grid[0].length;
       long[][] pl=new long[2][n+1];
       for(int i=1;i<=n;i++){
           pl[0][i]=pl[0][i-1]+grid[0][i-1];
           pl[1][i]=pl[1][i-1]+grid[1][i-1];
       }
       long ans=Long.MAX_VALUE;
       for(int i=1;i<=n;i++){
           ans=Math.min(ans,Math.max(pl[0][n]-pl[0][i],pl[1][i-1]));
       }
       return ans;
    }
}
